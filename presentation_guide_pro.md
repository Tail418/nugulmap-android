# 🦝 너굴맵(Neogulmap) 기술 심화 발표 가이드 (Pro Ver.)

본 가이드는 프로젝트의 아키텍처, 데이터 흐름, 기술적 의사결정 근거를 상세히 담고 있어 어떤 압박 질문에도 대응할 수 있도록 설계되었습니다.

---

## 📂 1. 시스템 아키텍처: Clean Architecture & MVVM
우리 프로젝트는 단순한 코드 나열이 아닌, **확장성**과 **테스트 가능성**을 고려한 3계층 클린 아키텍처를 채택했습니다.

### **[계층별 역할 및 존재 이유]**
1.  **Presentation Layer (UI)**:
    - **기술**: Jetpack Compose, ViewModel, StateFlow.
    - **역할**: 사용자의 입력을 받고 상태(State)를 화면에 렌더링.
    - **핵심 논리**: "UI는 상태를 반영할 뿐, 비즈니스 로직을 몰라야 한다." (선언형 UI의 장점)
2.  **Domain Layer (Pure Logic)**:
    - **기술**: UseCase, Domain Model (`Zone.kt`).
    - **역할**: 앱의 핵심 비즈니스 규칙 정의. 외부 라이브러리(Retrofit, Room 등)에 의존하지 않는 가장 순수한 Kotlin 코드.
    - **핵심 논리**: "플랫폼이나 서버가 바뀌어도 우리 서비스의 핵심 규칙은 변하지 않는다."
3.  **Data Layer (Infrastructure)**:
    - **기술**: RepositoryImpl, API(Retrofit), Local DB(Room), Mapper.
    - **역할**: 데이터를 가져오고 저장하는 구체적인 방법 구현.
    - **핵심 논리**: "데이터의 출처가 네트워크인지 로컬 DB인지 외부 계층은 알 필요가 없다." (데이터 캡슐화)

---

## 📊 2. 데이터 모델링 및 흐름 (DTO / Entity / Domain)
"왜 모델을 3개나 만들어서 번거롭게 변환(Mapping)하나요?"라는 질문에 대한 답변입니다.

1.  **ZoneDto (Data Transfer Object)**:
    - **목적**: 서버 API 명세에 종속적.
    - **이유**: 서버의 필드명이 바뀌거나 구조가 변경될 때, 앱 전체 코드가 깨지는 것을 방지하는 **'방화벽'** 역할.
2.  **ZoneEntity (Database Entity)**:
    - **목적**: RoomDB 테이블 구조에 종속적.
    - **이유**: DB의 인덱싱, 관계 설정 등 저장 효율에 최적화된 구조.
3.  **Zone (Domain Model)**:
    - **목적**: UI에서 보여주기 가장 편한 형태.
    - **이유**: API나 DB 구조에 상관없이 앱 내부에서 사용하는 '표준 언어'.

> **💡 꼬리 질문 대비: "Mapping 비용이 발생하지 않나요?"**
> "약간의 CPU 연산 비용은 발생하지만, 이로 인해 얻는 **코드 유지보수성**과 **결합도 해제(Decoupling)**의 이득이 훨씬 큽니다. 규모가 커질수록 이 구조가 버그를 줄여줍니다."

---

## 💻 3. 안드로이드 핵심 기술 (Deep Dive)

### **[Kakao Map SDK & Compose]**
- **도전 과제**: 카카오맵 SDK는 기존 XML View 기반이라 Compose와 직접 호환되지 않음.
- **해결책**: `AndroidView`를 활용하여 지도를 래핑하고, `DisposableEffect`를 통해 지도의 라이프사이클을 관리함.
- **성능 최적화**: 수백 개의 마커를 그릴 때 메인 스레드 부하를 줄이기 위해, 마커 클러스터링이나 화면 영역 내 데이터만 렌더링하는 로직을 고려함.

### **[Offline-first Strategy (Room)]**
- **로직**: `GetZonesUseCase` 실행 시 -> 1. 네트워크 확인 -> 2. 있으면 서버에서 데이터 Fetch 후 DB 업데이트 -> 3. 없으면 DB에서 즉시 로드.
- **사용자 이득**: 지하철 등 네트워크 불안정 구간에서도 끊김 없는 지도 확인 가능.

---

## ⚙️ 4. 백엔드 및 보안 (Security & DB)

### **[H2 Database의 전략적 사용]**
- **현상**: 개발 중에는 H2(In-memory), 배포 시에는 RDS(MySQL).
- **장점**: 개발자마다 DB를 설치할 필요가 없고, 테스트 코드를 돌릴 때마다 깨끗한 DB 상태를 유지할 수 있음. `application-dev.yml`과 `application-prod.yml`로 환경을 완벽히 분리함.

### **[OAuth2 & JWT 인증]**
- **OAuth2**: 구글/카카오로부터 사용자 식별자만 가져옴 (비밀번호 관리 위험 제거).
- **JWT**: Stateless한 서버 설계를 위해 사용. 서버가 세션을 유지할 필요가 없어 서버 확장성(Scalability)이 높음.

---

## 🛠️ 5. 개발 프로세스 및 트러블슈팅

### **[Git Merge & Conflict 해결]**
- **사례**: `HomeScreen.kt`에서 UI 변경과 ViewModel 로직 수정이 겹쳐 충돌 발생.
- **해결**: `git rebase`를 통해 커밋 히스토리를 정돈하고, 충돌 지점에서 팀원과 **'Pair Programming'**을 하며 코드의 최종본을 결정함.
- **예방**: 이후에는 기능별로 파일을 더 잘게 쪼개는 **'모듈화'**와 **'관심사 분리'**를 더 철저히 함.

---

## 🎯 6. 예상 꼬리 질문 리스트 (심화)

**Q: 공공데이터 업데이트 주기는 어떻게 대응하나요?**
- **A:** "현재는 데이터 스크립트(`Python`)를 통해 수동/정기적으로 업데이트하지만, 향후 공공데이터 API와 직접 연동하여 스케줄러(Spring Batch 등)를 통해 실시간 동기화를 구현할 계획입니다."

**Q: RoomDB 용량이 너무 커지면 어떡하나요?**
- **A:** "사용자 주변의 특정 반경 데이터만 캐싱하거나, 일정 시간이 지난 데이터는 자동 삭제하는 캐시 만료(Expiration) 정책을 도입하여 관리할 수 있습니다."

**Q: Compose에서 부모 리컴포지션이 잦아지면 지도 성능이 떨어지지 않나요?**
- **A:** "`derivedStateOf`나 `remember`를 적극적으로 활용하여 불필요한 리컴포지션을 방지하고, 지도 객체는 단 한 번만 생성되도록 싱글톤에 가깝게 관리하여 최적화했습니다."
